{"posts":[{"title":"一个C语言高校学生管理系统","content":"#include&lt;stdio.h&gt; #include&lt;conio.h&gt;//从键盘接收一个按键，无序按回车的那种 #include&lt;stdlib.h&gt; #include&lt;string.h&gt; //定义学生 typedef struct _Student { char name[20]; int age; char stuNum[20];//学号 float score;//成绩 }Student; //定义链表的结点 typedef struct _Node { Student stu;//学生-数据域 struct _Node* pNext;//指向下一个结点的指针 }Node; //定义头结点 Node* g_pHead = NULL; //录入 void Insert( char __name[],int __age,char __stuNum[],float __score) { //创建一个结点-动态开辟 Node* pNewNode = (Node*)malloc(sizeof(Node)); pNewNode-&gt;pNext = NULL; //头插法 if (g_pHead == NULL)//原来什么也没有 { g_pHead = pNewNode; } else { pNewNode-&gt;pNext = g_pHead; g_pHead = pNewNode; } strcpy(pNewNode-&gt;stu.name,__name); pNewNode-&gt;stu.age=__age; strcpy(pNewNode-&gt;stu.stuNum,__stuNum); pNewNode-&gt;stu.score=(float)__score; printf(&quot;您录入的数据为：\\n&quot;); printf(&quot;%s\\n&quot;,pNewNode-&gt;stu.name); printf(&quot;%d\\n&quot;,pNewNode-&gt;stu.age); printf(&quot;%s\\n&quot;,pNewNode-&gt;stu.stuNum); printf(&quot;%f\\n&quot;,pNewNode-&gt;stu.score); } //录入学生信息 void inputStudent() { char flag; char _name[20];int _age;char _stuNum[20];float _score; printf(&quot;请输入学生姓名:\\n&quot;); scanf(&quot;%s&quot;,_name);//name是数组名，不用加&amp; printf(&quot;请输入学生年龄:\\n&quot;); scanf(&quot;%d&quot;,&amp;_age); printf(&quot;请输入学生的学号:\\n&quot;); scanf(&quot;%s&quot;,_stuNum); printf(&quot;请输入学生的成绩:\\n&quot;); scanf(&quot;%f&quot;,&amp;_score); printf(&quot;是否录入,请输入y/n确认？\\n&quot;); flag=getch(); switch(flag) { case 'y':Insert(_name,_age,_stuNum,_score); printf(&quot;录入完成！\\n&quot;); break; case 'n':printf(&quot;取消成功！\\n&quot;); break; default :printf(&quot;重新输入！\\n&quot;); break; } system(&quot;pause&quot;); system(&quot;cls&quot;);//清屏 } //打印学生信息 void printStudent() { system(&quot;cls&quot;); printf(&quot;——————————————------——————————————------\\n&quot;); printf(&quot;*\\t————————欢迎使用高校学生管理系统——————----\\t\\n&quot;); printf(&quot;——————————————------——————————————------\\n&quot;); printf(&quot;*\\t学号\\t\\t*\\t姓名\\t\\t*\\t年龄\\t\\t*\\t成绩*\\t\\t\\n&quot;); printf(&quot;——————————————------——————————————------\\n&quot;); //遍历链表 Node* p = g_pHead; while (p != NULL) { printf(&quot;\\t\\t%s\\t\\t%s\\t\\t%d\\t\\t%.2f\\t\\t\\n&quot;,p-&gt;stu.stuNum,p-&gt;stu.name,p-&gt;stu.age,p-&gt;stu.score); p = p-&gt;pNext; } printf(&quot;——————————————------——————————————------\\n&quot;); system(&quot;pause&quot;); system(&quot;cls&quot;); } //保存学生信息 void saveStudent() { system(&quot;cls&quot;); //打开文件 FILE* fp = fopen(&quot;D:\\\\st.dat&quot;,&quot;w&quot;); if (fp == NULL) { printf(&quot;打开文件失败。\\n&quot;); return; } //遍历链表 Node* p = g_pHead; while (p != NULL) { fwrite(&amp;p-&gt;stu, 1,sizeof(Student),fp); p = p-&gt;pNext; } //关闭文件 fclose(fp); printf(&quot;保存数据成功。\\n&quot;); system(&quot;pause&quot;); system(&quot;cls&quot;); } //读取学生信息 void browerStudent() { static int count=0; //打开文件 if(count==1) { printf(&quot;不能重复读取，请退出重试！！\\n&quot;); system(&quot;pause&quot;); } else { FILE* fp = fopen(&quot;D:\\\\st.dat&quot;, &quot;r&quot;); if (fp == NULL) { printf(&quot;打开文件失败。\\n&quot;); system(&quot;pause&quot;); ; } else { //读文件 Student stu; while (fread(&amp;stu, 1, sizeof(Student), fp))//只要不是文件末尾就继续读 { //创建一个新结点 Node* pNewNode = (Node*)malloc(sizeof(Node)); pNewNode-&gt;pNext = NULL; memcpy(pNewNode,&amp;stu,sizeof(Student)); //头插法 if (g_pHead == NULL)//原来什么也没有 { g_pHead = pNewNode; } else { pNewNode-&gt;pNext = g_pHead; g_pHead = pNewNode; } } if(feof!=0) { printf(&quot;加载数据成功。\\n&quot;); system(&quot;pause&quot;); } } //关闭文件 fclose(fp); count=1; system(&quot;cls&quot;); } } //统计所有学生人数 int countStudent() { int nCount = 0; //遍历链表 Node* p = g_pHead; while (p != NULL) { nCount++; p = p-&gt;pNext; } return nCount; } //查找学生 Node* findStudent() { char nStudent[20]; char nName[20]; printf(&quot;请输入要查找的学生学号:\\n&quot;); scanf(&quot;%s&quot;, nStudent); printf(&quot;请输入要查找的学生姓名:\\n&quot;, nName); scanf(&quot;%s&quot;,nName); //遍历链表 Node* p = g_pHead; while (p != NULL) { if (p-&gt;stu.stuNum == nStudent || 0 == strcmp(p-&gt;stu.name , nName)) { return p; } p = p-&gt;pNext; } return NULL; } //修改学生信息 void modifyStudent() { char nStunum[20]; printf(&quot;请输入要修改学生的学号:\\n&quot;); scanf(&quot;%s&quot;, nStunum); Node* p = g_pHead; while (p != NULL) { if (strcmp(p-&gt;stu.stuNum,nStunum)==0) { printf(&quot;请输入修改学生的姓名 年龄 成绩：\\n&quot;); scanf(&quot;%s %d %f&quot;, p-&gt;stu.name, &amp;p-&gt;stu.age, &amp;p-&gt;stu.score); printf(&quot;修改成功。\\n&quot;); break; } p = p-&gt;pNext; } if (p == NULL) { printf(&quot;没有找到该学生信息。\\n&quot;); } system(&quot;pause&quot;); system(&quot;cls&quot;); } //删除学生信息 void deleteStudent() { char nStunum[20]; FILE* fp = fopen(&quot;D:\\\\st.dat&quot;, &quot;a&quot;); if (fp == NULL) { printf(&quot;文件加载失败。\\n&quot;); system(&quot;pause&quot;); ; } else { fclose(fp); printf(&quot;请输入要删除的学生学号。\\n&quot;); scanf(&quot;%s&quot;,nStunum); Node* p1,*p2; //判断是不是头结点 if (strcmp(g_pHead-&gt;stu.stuNum,nStunum)== 0) { p1 = g_pHead; g_pHead = g_pHead-&gt;pNext; free(p1); printf(&quot;删除成功。\\n&quot;); system(&quot;pause&quot;); system(&quot;cls&quot;); return; } //不是头结点 Node* p = g_pHead; while (p-&gt;pNext != NULL) { if (strcmp(p-&gt;pNext-&gt;stu.stuNum,nStunum)==0) { p2 = p-&gt;pNext; p-&gt;pNext = p-&gt;pNext-&gt;pNext; free(p2); printf(&quot;删除成功。\\n&quot;); system(&quot;pause&quot;); system(&quot;cls&quot;); return; } p = p-&gt;pNext; if (p-&gt;pNext == NULL) { break; } } if (p-&gt;pNext ==NULL) { printf(&quot;查无此人。\\n&quot;); } system(&quot;pause&quot;); system(&quot;cls&quot;); } system(&quot;cls&quot;); } //格式化 void delete() { int ret; if(login()==1) { FILE *fp; char filename[] = &quot;D:\\\\st.dat&quot;; fp = fopen(filename, &quot;w&quot;); if (fp == NULL) { printf(&quot;该文件不存在！！\\n&quot;); system(&quot;pause&quot;); system(&quot;cls&quot;); ; } fclose(fp); ret = remove(filename); if(ret == 0) { system(&quot;cls&quot;); printf(&quot;文件删除成功\\n&quot;); } else { system(&quot;cls&quot;); printf(&quot;错误：不能删除该文件！\\n&quot;); system(&quot;pause&quot;); } } } //主菜单 void mainMenu() { printf(&quot;——————————————------\\n&quot;); printf(&quot;*\\t欢迎使用高校学生管理系统*\\n&quot;); printf(&quot;——————————————------\\n&quot;); printf(&quot;*\\t1.录入学生信息\\t\\t*\\n&quot;); printf(&quot;*\\t2.打印学生信息\\t\\t*\\n&quot;); printf(&quot;*\\t3.保存学生信息\\t\\t*\\n&quot;); printf(&quot;*\\t4.读取学生信息\\t\\t*\\n&quot;); printf(&quot;*\\t5.统计所有学生人数\\t*\\n&quot;); printf(&quot;*\\t6.查找学生信息\\t\\t*\\n&quot;); printf(&quot;*\\t7.修改学生信息\\t\\t*\\n&quot;); printf(&quot;*\\t8.删除学生信息\\t\\t*\\n&quot;); printf(&quot;*\\t9.格式化数据文件\\t*\\n&quot;); printf(&quot;*\\t0.退出系统\\t\\t*\\n&quot;); printf(&quot;——————————————------\\n&quot;); } //键盘输入 void keyDown() { char ch = _getch(); switch (ch) { case '1'://录入 inputStudent(); break; case '2'://打印 printStudent(); break; case '3'://保存 saveStudent(); break; case '4'://读取 browerStudent(); break; case '5'://统计 printf(&quot;学生总人数为:%d\\n&quot;, countStudent()); system(&quot;pause&quot;); system(&quot;cls&quot;); break; case '6'://查找 { Node* p = findStudent(); if (p != NULL) { printf(&quot;学号:%s\\t姓名:%s\\t年龄:%d\\t成绩:%f\\n&quot;, p-&gt;stu.stuNum, p-&gt;stu.name, p-&gt;stu.age, p-&gt;stu.score); } else { printf(&quot;没有找到该学生。\\n&quot;); } system(&quot;pause&quot;); system(&quot;cls&quot;); break; } case '7'://修改 modifyStudent(); break; case '8'://删除 deleteStudent(); break; case '9'://格式化 delete(); break; case '0'://退出 exit(0); break; default: system(&quot;cls&quot;); system(&quot;pause&quot;); printf(&quot;输入错误，请重新输入。\\n&quot;); break; } } int login() { char password[]=&quot;990820&quot;; int i; char input[10]; for(i=0;i&lt;3;i++) { printf(&quot;请输入密码:\\n&quot;); scanf(&quot;%s&quot;,input); if(strcmp(input,password) == 0) break; else if (i&lt;3) printf(&quot;密码错误,重新输入!\\n&quot;); system(&quot;cls&quot;); } if(i&lt;3) { printf(&quot;登陆成功!\\n&quot;); return 1; } else printf(&quot;密码错误!\\n&quot;); return -1; system(&quot;cls&quot;); } int main(void) { if(login()==-1) exit(0); else while (1) { mainMenu(); keyDown(); } return 0; } ","link":"https://tong125847.github.io/post/yi-ge-c-yu-yan-gao-xiao-xue-sheng-guan-li-xi-tong/"},{"title":"Linux基础命令---tune2fs","content":"tune2fs tune2fs允许系统管理员在Linux ext2、ext3或ext4文件系统上调整各种可调的文件系统参数。这些选项的当前值可以使用-l选项显示，也可以通过使用dumpe2fs (8)程序显示。 此命令的适用范围：RedHat、RHEL、Ubuntu、CentOS、SUSE、openSUSE、Fedora。 1、语法 tune2fs [选项] device tune2fs [ -l ] [ -c max-mount-counts ] [ -e errors-behavior ] [ -f ] [ -i interval-between-checks ] [ -j ] [ -J journal-options ] [ -m reserved-blocks-percentage ] [-o [^]mount-options[,...] ] [ -r reserved-blocks-count ] [ -s sparse-super-flag ] [ -u user ] [ -g group ] [ -C mount-count ] [ -E extended-options ] [ -L volume-name ] [ -M last-mounted-directory ] [ -O [^]feature[,...] ] [ -T time-last-checked ] [ -U UUID ] device 2、选项列表 选项 说明 -l 显示设备的详细信息 -c max-mount-counts 检查文件系统之前，调整最大挂载次数。如果最大挂载计数为0或-1，e2fsck(8)和内核将忽略文件系统的挂载次数。如果对强制检查文件系统的挂载计数，将避免在使用日志文件系统时一次检查所有文件系统。 -C mount-count 设置文件系统的挂载次数，如果设置为比-c选项设置的max-mount-counts参数更大的值，e2fsck(8)将在下次重新启动时检查文件系统。 -e error-behavior 当检测到错误时，更改内核代码的行为。在任何情况下，文件系统错误都会导致e2fsck(8)在下一次引导时检查文件系统。错误行为可以是下列行为之一： continue，继续执行正常执行。 remount-ro，重新以只读的方式挂载。 panic，产生kernel panic。 -E extended-options 为文件系统设置扩展选项。扩展选项是逗号分隔的，可以使用相等号(‘=’)符号进行参数化。支持下列扩展选项： stride=stride-size，为RAID数组配置具有步长文件系统块的文件系统。这是在移动到下一个磁盘之前读取或写入磁盘的块数。这主要影响文件系统元数据(如位图)在mke2fs(2)时间的放置，以避免将它们放置在单个磁盘上，这可能会损害性能。它也可以被块分配器使用。 stripe_width=stripe-width，为RAID数组配置文件系统，每条带宽的文件系统块。这通常是stride-size *N，其中N是RAID中数据磁盘的数目(例如RAID 5 N+1，RAID 6 N+2)。这允许块分配器在写入数据时防止对RAID条中的奇偶性进行读-修改-写入(如果可能的话)。 hash_alg=hash-alg，设置用于具有散列b树目录的文件系统的默认哈希算法。接受的有效算法有：legacy、half_md4和tea。 mount_opts=mount_option_string，设置一组默认的挂载选项，这些选项将在挂载文件系统时使用。与使用-o选项指定的基于位掩码的默认挂载选项不同，mount_option_string是最大长度为63字节的任意字符串，存储在超级块中。ext 4文件系统驱动程序将首先应用基于位掩码的默认选项，然后在解析从mount (8)程序传递的挂载选项之前解析mount_option_string。此超级块设置仅在2.6.35以上内核中执行，而ext2和ext3文件系统驱动程序则完全不执行。 test_fs，在文件系统超级块中设置一个标志，指示可以使用试验性内核代码(如ext4dev文件系统)挂载它。 ^test_fs，清除test_fs标志，指示仅使用production-level文件系统代码挂载文件系统。 -f 强制执行。当从具有外部日志的文件系统(或损坏到似乎有外部日志)而外部日志不可用的文件系统中删除Has_Journal文件系统特性时，此选项非常有用。 -g group 设置可以使用保留文件系统块的组。group参数可以是数值gid或组名。如果给定组名，则在将其存储在超级块之前，将其转换为数字gid。 -i interval-between-checks[d|m|w] 调整两个文件系统检查之间的最大时间。没有后缀或d将数字间隔检查解释为天，m为月，w为周.值为零将禁用与时间相关的检查。强烈建议启用-c(mount-count-dependent)检查或-i(time-dependent)检查，以强制对文件系统进行定期完整的e2fsck(8)检查。如果不这样做，可能会导致文件系统损坏(由于磁盘、电缆、内存或内核错误)而忽略，最终导致数据丢失或损坏。 -j 向文件系统添加ext3日志，如果没有指定-J选项，则将使用默认日志参数来创建存储在文件系统中的适当大小的日志(给定文件系统的大小)。请注意，您必须使用具有ext3支持的内核才能实际使用日志。 如果此选项用于在已安装的文件系统上创建日志，则将在文件系统的顶层目录中创建一个不可变的文件，即日志，因为它是在安装文件系统时创建日志inode的唯一安全方法。虽然ext 3日志是可见的，但在安装文件系统时删除它或修改它是不安全的；因此，文件被标记为不可变。在检查未挂载的文件系统时，e2fsck(8)将自动将.Journal文件移动到不可见的保留日志inode。对于除根文件系统以外的所有文件系统，这应该在下一个重新启动周期中自动和自然地发生。由于根文件系统是只读安装的，因此必须从救援软盘上运行e2fsck(8)才能完成此转换。 -J journal-options 重写默认ext 3日志参数。日记选项是逗号分隔的，可以使用相等号(‘=’)符号进行参数化。支持下列日志选项： size=journal-size，创建一个存储在文件系统中的日志，大小journal-size。日志的大小必须至少为1024个文件系统块(如果使用1k块，则为1MB；如果使用4k块，则为4MB)。并且可能不超过102，400个文件系统块。文件系统中必须有足够的空闲空间来创建这样大小的日志。 device=external-journal，将文件系统附加到位于外部日志上的日志块设备上。外部日志必须已使用以下命令创建“mke2fs -O journal_dev external-journal”。注意，外部日志必须与将要使用的文件系统以相同的块大小进行格式化。此外，虽然支持将多个文件系统附加到单个外部日志，但Linux内核和e2fsck(8)目前还不支持共享外部日志。除了直接指定设备名称之外，还可以通过LABEL=label或UUID=UUID指定外部日志，以便通过存储在日志开头的ext2超级块中的卷标签或UUID来定位外部日志。使用dupe2fs(8)显示日志设备的卷标签和UUID。 size和device只能有一个。 -L volume-label 设置文件系统卷标。ext2文件系统标签最多可以长达16个字符；如果卷标签超过16个字符，tune2fs将截断它并打印警告。卷标签可由mount(8)、fsck(8)和/etc/fstab(5)(可能还有其他)使用，方法是指定LABEL=volume_label，而不是/dev/hda 5这样的块特殊设备名。 -m reserved-blocks-percentage 设置只能由特权进程分配的文件系统百分比。保留一些文件系统块以供特权进程使用是为了避免文件系统碎片，并允许系统守护进程(如syAdd.1-d(8)在非特权进程被阻止写入文件系统之后继续正确运行。通常，保留块的默认百分比是5%。 -M last-mounted-directory 设置最后的挂载目录 -o [^]mount-option[,...] 在文件系统中设置或清除指定的默认挂载选项。默认的挂载选项可以被“/etc/fstab”(5)中指定的挂载选项覆盖，也可以在命令行参数上覆盖mount(8)。旧内核可能不支持此特性；特别是，在2.4.20之前的内核几乎肯定会忽略超级块中的默认挂载选项字段。可以通过用逗号分隔功能来清除或设置多个挂载选项。以插入字符(‘^’)为前缀的挂载选项将在文件系统的超级块中清除；没有前缀字符的挂载选项或以‘+’作为前缀的挂载选项将添加到文件系统中。可以使用tune2fs设置或清除下列挂载选项： debug，bsdgroups，user_xattr，acl，uid16，journal_data，journal_data_ordered，journal_data_writeback，nobarrier，block_validity，discard，nodelalloc -O[^]feature[,...] 设置或清除文件系统中指定的文件系统特性(选项)。多个文件系统特性可以通过用逗号分隔特性来清除或设置。以插入字符(‘^’)为前缀的文件系统特性将在文件系统的超级块中清除；没有前缀字符或前缀为‘+’的文件系统特性将添加到文件系统中。可以使用tune2fs设置或清除下列文件系统特性：dir_index，filetype，flex_bg，has_journal，large_file，resize_inode，sparse_super，uninit_bg。 -r reserved-blocks-count 设置保留文件系统块的数目 -T time-last-checked 使用e2fsck设置上次检查文件系统的时间。时间使用当前(本地)时区进行解释。这在使用逻辑卷管理器对文件系统进行一致快照的脚本中很有用，然后在空闲时间检查文件系统，以确保它没有因为硬件问题而损坏，等等。如果文件系统是干净的，那么这个选项可以用来设置原始文件系统上的最后一次检查时间。最后一次检查的格式是国际日期格式，有一个可选的时间说明符，即YYYYMMDD[HH[MM[SS]。关键字Now也被接受，在这种情况下，上一次检查时间将设置为当前时间。 -u user 设置可以使用保留文件系统块的用户。用户可以是uid或用户名。如果给定用户名，则将其转换为数字uid，然后将其存储在超级块中。 -U UUID 将文件系统的通用唯一标识符(UUID)设置UUID。UUID的格式是由连字符分隔的一系列十六进制数字，如“c1b9d5a2-f162-11cf-9ece-0020afc76f16”。UUID参数也可能是以下内容之一： clear，清除UUID。 random，产生一个随机的UUID。 time，产生一个基于时间的UUID。 3、实例 1）查看sdb4的详细信息 [root@localhost ~]# tune2fs -l /dev/sdb4 tune2fs 1.41.12 (17-May-2010) Filesystem volume name: hello Last mounted on: Filesystem UUID: e2a0cb30-f3ca-47de-92b8-780296960d93 … First inode: 11 Inode size: 128 Default directory hash: half_md4 Directory Hash Seed: 4930bf0f-771e-4940-9255-bee40d138079 2）设置最大挂载次数 [root@localhost ~]# tune2fs -c 30 /dev/sdb4 //设置最大挂载次数 tune2fs 1.41.12 (17-May-2010) Setting maximal mount count to 30 You have new mail in /var/spool/mail/root [root@localhost ~]# tune2fs -l /dev/sdb4 //查看详细信息 tune2fs 1.41.12 (17-May-2010) Filesystem volume name: hello Maximum mount count: 30 //最大挂载次数已经修改为30 Directory Hash Seed: 4930bf0f-771e-4940-9255-bee40d138079 [root@localhost ~]# ","link":"https://tong125847.github.io/post/linux-ji-chu-ming-ling-tune2fs/"},{"title":"链表","content":"#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct student { int num; int score; char name[20]; struct student *next; } STU; //链表创建(尾插法) void link_creat_head(STU **p_head,STU *p_new) { STU *p_mov=*p_head; if(*p_head==NULL) {*p_head=p_new; p_new-&gt;next=NULL; } else { while(p_mov-&gt;next!=NULL) {p_mov=p_mov-&gt;next; } p_mov-&gt;next=p_new; p_new-&gt;next=NULL; } } //遍历链表 void link_print(STU *head) { STU *p_mov; p_mov=head; while(p_mov!=NULL) { printf(&quot;num=%d,score=%d,name=%s\\n&quot;,p_mov-&gt;num,p_mov-&gt;score,p_mov-&gt;name); p_mov=p_mov-&gt;next; } } //释放链表 void link_free(STU **p_head) { STU *pb=*p_head; while(*p_head!=NULL) { pb=*p_head; *p_head=(*p_head)-&gt;next; free(pb); pb=NULL; } printf(&quot;链表释放成功&quot;); } //链表的查找（查找某个学号） STU* link_search_num(STU *head,int num) { STU *p_mov; p_mov=head; while(p_mov!=NULL) { if(p_mov-&gt;num==num) { printf(&quot;找到了！！&quot;); return p_mov; } p_mov=p_mov-&gt;next; } printf(&quot;没找到！&quot;); return NULL; } //链表的查找（查找某个姓名） STU *link_search_name(STU *head,char *name) { STU *p_mov; p_mov=head; while(p_mov!=NULL) { if(strcmp(p_mov-&gt;name,name)==0) { printf(&quot;找到了！！&quot;); return p_mov; } } printf(&quot;没找到！&quot;); return NULL; } //链表节点的删除 void link_delete_num(STU **p_head,int num) { STU *pb,*pf; pb=*p_head;pf=*p_head; if(*p_head==NULL) { printf(&quot;链表为空，没有您要删除的节点&quot;); return; } while((pb-&gt;num!=num)&amp;&amp;(pb-&gt;next!=NULL)) { pf=pb; pb=pb-&gt;next; } if(pb-&gt;num==num) { if(pb==*p_head) { *p_head=pb-&gt;next; printf(&quot;已删除\\n&quot;); } else { printf(&quot;删除成功\\n&quot;); pf-&gt;next=pb-&gt;next; } free(pb); pb=NULL; } else { printf(&quot;没有您要删除的节点&quot;); } } //插入指定位置前中后 void link_insert_num(STU **p_head,STU *p_new) { STU *pb,*pf; pb=pf=*p_head; if(*p_head==NULL) { *p_head=p_new; p_new-&gt;next=NULL; return ; } while((p_new-&gt;num&gt;=pb-&gt;num)&amp;&amp;(pb-&gt;next!=NULL)) { pf=pb; pb=pb-&gt;next; } if(p_new-&gt;num&lt;pb-&gt;num) { p_new-&gt;next=*p_head; *p_head=p_new; } else { pb-&gt;next=p_new; p_new-&gt;next=NULL; } } //链表的排序 void link_order(STU *head) { STU *pb,*pf,temp; pf=head; if(head==NULL) { printf(&quot;链表为空，不用排序&quot;); return; } if(head-&gt;next==NULL) { printf(&quot;只有一个节点，不用排序&quot;); return; } while(pf-&gt;next!=NULL) { pb=pf-&gt;next; while(pb!=NULL) { if(pf-&gt;num&gt;pb-&gt;num) {temp=*pb; *pb=*pf; *pf=temp; temp.next=pb-&gt;next; pb-&gt;next=pf-&gt;next; pf-&gt;next=temp.next; } pb=pb-&gt;next; } pf=pf-&gt;next; } } //链表逆序 STU *link_reverse(STU *head) { STU *pf,*pb,*r; pf=head; pb=pf-&gt;next; while(pb!=NULL) { r=pb-&gt;next; pb-&gt;next=pf; pf=pb; pb=r; } head-&gt;next=NULL; head=pf; return head; } int main() { STU *head=NULL,*p_new=NULL; int num,i; printf(&quot;请输入链表初始化个数\\n&quot;); scanf(&quot;%d&quot;,&amp;num); for(i=0;i&lt;num;i++) { p_new=(STU*)malloc(sizeof(STU)); printf(&quot;请输入学号、分数、名字：\\n&quot;); scanf(&quot;%d %d %s&quot;,&amp;p_new-&gt;num,&amp;p_new-&gt;score,p_new-&gt;name); link_creat_head(&amp;head,p_new); } link_print(head); //link_free(&amp;head); // link_search_num(head,1001); // link_search_name(head,&quot;xxx&quot;); link_delete_num(&amp;head,1001); /* while(1) { printf(&quot;请输入您要插入的节点的num score name\\n&quot;); p_new=(STU*)malloc(sizeof(STU)); scanf(&quot;%d %d %s&quot;,&amp;p_new-&gt;num,&amp;p_new-&gt;score,p_new-&gt;name); link_insert_num(&amp;head,p_new); link_print(head); }*/ //link_order(head); printf(&quot;**********************\\n&quot;); //head=link_reverse(head); link_print(head); link_free(&amp;head); return 0; } ","link":"https://tong125847.github.io/post/lian-biao/"},{"title":"C语言随记","content":"结构体字节对齐，C语言结构体字节对齐详解 struct STUDENT { char a; int b; }data; 如上结构体变量 data 占多少字节？char 占 1 字节，int 占 4 字节，所以总共占 5 字节吗？我们写一个程序验证一下： # include &lt;stdio.h&gt; struct STUDENT { char a; int b; }data; int main(void) { printf(&quot;%p, %p\\n&quot;, &amp;data.a, &amp;data.b); //%p是取地址输出控制符 printf(&quot;%d\\n&quot;, sizeof(data)); return 0; } 输出结果是： 00427E68, 00427E6C 8 我们看到 data 不是占 5 字节，而是占 8 字节。变量 a 的地址是从 00427E68 到 00427E6B，占 4字 节；变量 b 的地址是从 00427E6C 到 00427E6F，也占 4 字节。b 占 4 字节我们能理解，但 a 是 char 型，char 型不是占 1 字节吗，这里为什么占 4 字节？其实不是它占了 4 字节，它占的还是 1 字节，只不过结构体中有一个字节对齐的概念。 什么叫字节对齐？我们知道结构体是一种构造数据类型，里面可以有不同数据类型的成员。在这些成员中，不同的数据类型所占的内存空间是不同的。那么系统是怎么给结构体变量的成员分配内存的呢？或者说这些成员在内存中是如何存储的呢？通过上面这个例子我们知道肯定不是顺序存储的。 那么到底是怎么存储的呢？就是按字节对齐的方式存储的！即以结构体成员中占内存最多的数据类型所占的字节数为标准，所有的成员在分配内存时都要与这个长度对齐。我们举一个例子：我们以上面这个程序为例，结构体变量 data 的成员中占内存最多的数据类型是 int 型，其占 4 字节的内存空间，那么所有成员在分配内存时都要与 4 字节的长度对齐。也就是说，虽然 char 只占 1 字节，但是为了与 4 字节的长度对齐，它后面的 3 字节都会空着，即： 所谓空着其实也不是里面真的什么都没有，它就同定义了一个变量但没有初始化一样，里面是一个很小的、负的填充字。为了便于表达，我们就暂且称之为空好了。 如果结构体成员为： struct STUDENT { char a; char b; int c; }data; 那么这三个成员是怎么对齐的？a 和 b 后面都是空 3 字节吗？不是！如果没有 b，那么 a 后面就空 3 字节，有了 b 则 b 就接着 a 后面填充。即： 所以这时候结构体变量 data 仍占 8 字节。我们写一个程序验证一下： # include &lt;stdio.h&gt; struct STUDENT { char a; char b; int c; }data; int main(void) { printf(&quot;%p, %p, %p\\n&quot;, &amp;data.a, &amp;data.b, &amp;data.c); //%p是取地址输出控制符 printf(&quot;%d\\n&quot;, sizeof(data)); return 0; } 输出结果是： 00427E68, 00427E69, 00427E6C 8 这时我们发现一个问题：所有成员在分配内存的时候都与 4 字节的长度对齐，多个 char 类型时是依次往后填充，但是 char 型后面的 int 型为什么不紧接着后面填充？为什么要另起一行？也就是说，到底什么时候是接在后面填充，什么时候是另起一行填充？ 我们说，所有的成员在分配内存时都要与所有成员中占内存最多的数据类型所占内存空间的字节数对齐。假如这个字节数为 N，那么对齐的原则是：理论上所有成员在分配内存时都是紧接在前一个变量后面依次填充的，但是如果是“以 N 对齐”为原则，那么，如果一行中剩下的空间不足以填充某成员变量，即剩下的空间小于某成员变量的数据类型所占的字节数，则该成员变量在分配内存时另起一行分配。 下面再来举一个例子，大家觉得下面这个结构体变量data占多少字节？ struct STUDENT { char a; char b; char c; char d; char e; int f; }data; 首先最长的数据类型占 4 字节，所以是以 4 对齐。然后 a 占 1 字节，b 接在 a 后面占 1 字节，c 接在 b 后面占 1 字节，d 接在 c 后面占 1 字节，此时满 4 字节了，e 再来就要另起一行。f 想紧接着 e 后面分配，但 e 后面还剩 3 字节，小于 int 类型的 4 字节，所以 f 另起一行。即该结构体变量分配内存时如下： 即总共占 12 字节。我们写一个程序验证一下： # include &lt;stdio.h&gt; struct STUDENT { char a; char b; char c; char d; char e; int f; }data; int main(void) { printf(&quot;%p, %p, %p, %p, %p, %p\\n&quot;, &amp;data.a, &amp;data.b, &amp;data.c, &amp;data.d, &amp;data.e, &amp;data.f); //%p是取地址输出控制符 printf(&quot;%d\\n&quot;, sizeof(data)); return 0; } 输出结果是： 00427E68, 00427E69, 00427E6A, 00427E6B, 00427E6C, 00427E70 12 现在大家应该能掌握字节对齐的精髓了吧！下面给大家出一个题目试试掌握情况。我们将前面的结构体改一下： struct STUDENT { char a; int b; char c; }data; 即将原来第二个和第三个声明交换了位置，大家看看现在 data 变量占多少字节？没错，是 12 字节。首先最长类型所占字节数为 4，所以是以 4 对齐。分配内存的时候 a 占 1 字节，然后 b 想紧接着 a 后面存储，但 a 后面还剩 3 字节，小于 b 的 4 字节，所以 b 另起一行分配。然后 c 想紧接着 b 后面分配，但是 b 后面没空了，所以 c 另起一行分配。所以总共 12 字节。内存分配图如下所示： 下面写一个程序验证一下： # include &lt;stdio.h&gt; struct STUDENT { char a; int b; char c; }data; int main(void) { printf(&quot;%p, %p, %p\\n&quot;, &amp;data.a, &amp;data.b, &amp;data.c); //%p是取地址输出控制符 printf(&quot;%d\\n&quot;, sizeof(data)); return 0; }``` 输出结果是： 00427E68, 00427E6C, 00427E70 12 我们看到，同样三个数据类型，只不过交换了一下位置，结构体变量data所占的内存空间就由8字节变成12字节，多了4字节。这就告诉我们，在声明结构体类型时，各类型成员的前后位置会对该结构体类型定义的结构体变量所占的字节数产生影响。没有规律的定义会增加系统给结构体变量分配的字节数，降低内存分配的效率。但这种影响对操作系统来说几乎是可以忽略不计的！所以我们在写程序的时候，如果有心的话，声明结构体类型时就按成员类型所占字节数从小到大写，或从大到小写。但是如果没有按规律书写的话也不要紧，声明结构体类型时并非一定要从小到大声明，只是为了说明“字节对齐”这个概念！而且有时候为了增强程序的可读性我们就需要没有规律地写，比如存储一个人的信息： ```c struct STUDENT { char name[10]; int age; char sex; float score; }data; 正常的思维是将“性别”放在“年龄”后面，但如果为了内存对齐而交换它们的位置，总让人觉得有点别扭。所以我说“尽量”有规律地写！ 这时又有人会提出一个问题：“上面这个结构体变量 data 中有成员 char name[10]，长度最长，是 10，那是不是要以 10 对齐？”不是，char a[10] 的本质是 10 个 char 变量，所以就把它当成 10 个 char 变量看就行了。所以结构体变量 data 中成员最长类型占 4 字节，还是以 4 对齐。该结构体变量分配内存时情况如下： 总共 24 字节，我们写一个程序验证一下： # include &lt;stdio.h&gt; struct STUDENT { char name[10]; int age; char sex; float score; }data; int main(void) { printf(&quot;%p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p\\n&quot;, &amp;data.name[0], &amp;data.name[1], &amp;data.name[2], &amp;data.name[3], &amp;data.name[4], &amp;data.name[5], &amp;data.name[6], &amp;data.name[7], &amp;data.name[8], &amp;data.name[9], &amp;data.age, &amp;data.sex, &amp;data.score); printf(&quot;%d\\n&quot;, sizeof(data)); return 0; } 输出结果是： 00427E68, 00427E69, 00427E6A, 00427E6B, 00427E6C, 00427E6D, 00427E6E, 00427E6F, 00427E70, 00427E71, 00427E74, 00427E78, 00427E7C 24 ","link":"https://tong125847.github.io/post/c-yu-yan-sui-ji/"},{"title":"Qt Creator学习","content":"杂：Qt的安装，工程的创建。Application---Qt Widgets Application（创建一个桌面Qt应用，包含一个基于Qt设计师的主窗体） widget空窗口 { mainwindow主窗口 dialog对话框 } 版本控制系统（SVN Git）代码同步工具 文件： .pro #------------------------------------------------- # # Project created by QtCreator 2020-11-29T16:30:48 # #------------------------------------------------- #为QT添加核心模块 gui图形用户界面模块 QT += core gui #4.0以后的版本，添加widgets模块 greaterThan(QT_MAJOR_VERSION, 4): QT += widgets #生成的.exe应用程序 名字 TARGET = 2020-11-29 #使用的模板 TEMPLATE = app # The following define makes your compiler emit warnings if you use # any feature of Qt which has been marked as deprecated (the exact warnings # depend on your compiler). Please consult the documentation of the # deprecated API in order to know how to port your code away from it. #定义选项添加QT_DEPRECATED_WARNINGS当API过时时，编译器提升警告 DEFINES += QT_DEPRECATED_WARNINGS # You can also make your code fail to compile if you use deprecated APIs. # In order to do so, uncomment the following line. # You can also select to disable deprecated APIs only up to a certain version of Qt. #DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0 #支持C++11新特性 CONFIG += c++11 SOURCES += \\ main.cpp \\ widgets.cpp HEADERS += \\ widgets.h FORMS += \\ widgets.ui # Default rules for deployment. qnx: target.path = /tmp/$${TARGET}/bin else: unix:!android: target.path = /opt/$${TARGET}/bin !isEmpty(target.path): INSTALLS += target ``` main.cpp ```cpp #include &quot;widgets.h&quot; #include &lt;QApplication&gt;//应用程序头文件 /* *QT编辑器快捷键 * 注释 Ctrl+/ * 运行 Ctrl+r * 构建 Ctrl+b * 转到定义 F2 * 返回Alt+left键 * 前进Alt+right键 */ int main(int argc, char *argv[]) { QApplication a(argc, argv);//定义应用程序对象 widgets w;//定义空窗口对象 w.show();//调用空窗口子函数 显示窗口 return a.exec();//调用应用程序对象消息循环函数 } .h #ifndef WIDGETS_H #define WIDGETS_H//宏定义 #include &lt;QMainWindow&gt;//包含Qt空窗口头文件 namespace Ui { class widgets; } class widgets : public QMainWindow { Q_OBJECT//支持信号 和 槽 public: explicit widgets(QWidget *parent = nullptr);//构造函数 ~widgets();//析构函数 private: Ui::widgets *ui; }; #endif // WIDGETS_H .cpp #include &quot;widgets.h&quot; #include &quot;ui_widgets.h&quot; widgets::widgets(QWidget *parent) : QMainWindow(parent), ui(new Ui::widgets) { ui-&gt;setupUi(this); this-&gt;setWindowTitle(&quot;Hello QT&quot;);//设置窗口标题 this-&gt;resize(400,800);//设置窗口大小（宽x高） //this-&gt;setFixedSize(200,200);//固定窗口大小，无法该改变窗口大小和移动 //创建按钮 } widgets::~widgets() { delete ui; } .ui ","link":"https://tong125847.github.io/post/qt-creator-xue-xi/"},{"title":"Ubuntu学习（第一天）","content":"==========开发环境================= Ubuntu 16.04 64位的linux 系统 Ubuntu 12.04 32位的linux系统 6818开发板---32位的linux内核，使用是linux内核6.25.7.35版本 如果要用64位系统开发32位的开发板，需要搭建编译工具环境 ==========Linux设置共享文件夹========== （1）在电脑中新建一个可以共享的文件夹 （2）点击”虚拟机”---“设置”---“选项”---“共享文件夹” ---“总是启用”---“添加”---输入被共享的文件夹名称，然 后一直点“下一步”，直到“完成”。 &lt;www.kernel.org&gt; ===========常用linux命令============= （1）cd进入或者退出文件夹 cd .. 退出当前文件夹，回到上一级目录 cd +文件夹名称 进入到该文件夹 （2）ls 查看文件夹内容 ls 查看当前文件夹的名称 ls -l 查看当前文件夹中文件的详细信 （3）touch 创建文件 （4）rm 删除文件 （5）mkdir 创建文件夹 mkdir + 名称 （6）rmdir 删除文件夹(默认要求文件夹为空) （7）cp 拷贝文件 cp 文件1 文件2 拷贝普通文件 其他命令：chmod，ifconfig,mv等等 练习一： 设置共享文件夹，在共享文件夹中创建111,222,333 三个文件夹，并且在文件夹中分别创建同名文件，然后使用cp命令拷贝111文件夹成777。 ================================= 修改终端颜色： 在终端的任意空白位置，右键选择“Profiles”----“Profiles Preference”----“color”就可以自行调整终端的颜色 rm 文件名称 -rf 强制删除文件，不管该文件是什么 pwd :查看当前所在的路径 /mnt/hgfs：ubuntu共享文件夹的标准前缀。 写代码的文件: 源代码 可以运行的文件: 可执行程序 编译程序： gcc 源代码 ‘-o’ 可执行程序 运行可执行程序: ./可执行程序 建议同学们在编写程序的时候，把“文件扩展名”√上，防止文件名弄错。 ===============程序编译================== （1）解析头文件，解析宏定义 得到的hello.i仍然是高级语言 （2）把高级语言转成汇编语言 得到的hello.s是汇编语言 （3）把汇编语言转成二进制机器语言 得到的hello.o就是机器语言 （4）把一个或多个链接文件组合成一个可执行程序 得到的就是可执行文件 综合在一起： =======================C语言常用结构======================= （1）数据类型 int类型 4字节 存放整型数据 char类型 1字节 存放字符类型数据，但同样也可以表示0~255的数值。 具体数值可以查看ASCII表格，使用”man ASCII”。 （2）循环 for循环 for(初始条件 ； 判断条件 ； 结束动作 ) { 执行动作 } 当初始条件满足判断条件并且为真的时候，程序运行”执行动作”,当“执行动作”结束以后，运行一次“结束动作”，然后再”判断条件”。 while循环 while(判断条件) { 执行动作 } 当判断条件是真的时候，程序运行执行动作 使用printf打印倒的三层三角形 ***** *** * test1.c 练习2： 使用printf打印：正的四层三角形 * *** ***** ******* 作业： 在网络上找一个叫做“2048”的游戏，然后了解其中的数学逻辑。 //data_type #include &lt;stdio.h&gt; int main() { int a=100; printf(&quot;地址=%p\\n&quot;,&amp;a); printf(&quot;大小=%d\\n&quot;,sizeof(a)); char b = 'A'; printf(&quot;b=%d,b=%p\\n&quot;,b,&amp;b); return 0; } //for #include &lt;stdio.h&gt; int main() { int i; //变量i从数值0开始，如果它的数值小于5，那么就执行{}里面的内容 //并且每次执行完毕以后，进行 i++ ,也就是自己加1 //直到i的数值大于等于5的时候，就不再执行{}里面的内容。 for(i=0;i&lt;5;i++) { printf(&quot;i=%d\\n&quot;,i); } return 0; } //hello #include &lt;stdio.h&gt; int main() { int a=100; printf(&quot;地址=%p\\n&quot;,&amp;a); printf(&quot;大小=%d\\n&quot;,sizeof(a)); char b = 'A'; printf(&quot;b=%d,b=%p\\n&quot;,b,&amp;b); return 0; } //test1 #include &lt;stdio.h&gt; int main() { int i,j; for(i=0;i&lt;3;i++) { for(j=0;j&lt;i;j++) printf(&quot; &quot;); for(j=0;j&lt;2*(2-i)+1;j++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); } /******* 第一次输出： i=0的时候 j也是从0开始，j&lt;i 不成立，不会打印&quot; &quot; j&lt;2*(2-0)+1 一共会执行5次 第二次输出： i=1的时候 j&lt;i成立，打印一次&quot; &quot; j&lt;2*(2-1)+1 一共会执行3次 第三次输出： i=2的时候 j&lt;i成立，打印两次&quot; &quot; j&lt;2*(2-2)+1 一共会执行1次 *******/ return 0; } //test2 #include &lt;stdio.h&gt; int main() { int ceng = 7; int i,j; for(i=0;i&lt;ceng;i++) { for(j=0;j&lt;ceng-1-i;j++) printf(&quot; &quot;); for(j=0;j&lt;2*i+1;j++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); } return 0; } //while #include &lt;stdio.h&gt; int main() { int i=0; //只要i小于5，就执行{}里面的内容 while(i&lt;5) { printf(&quot;i=%d\\n&quot;,i); i++; } return 0; } ","link":"https://tong125847.github.io/post/ubuntu-xue-xi-2020-11-02di-yi-tian/"},{"title":"插入图片Markdown","content":"Markdown插图片有三种方法，各种Markdown编辑器的插图方式也都包含在这三种方法之内。 插图最基础的格式就是： ![Alt text](图片链接 &quot;optional title&quot;) image.png 插入本地图片 只需要在基础语法的括号中填入图片的位置路径即可，支持绝对路径和相对路径。 例如： ![avatar](/home/picture/1.png) image.png 插入网络图片 只需要在基础语法的括号中填入图片的网络链接即可，现在已经有很多免费/收费图床和方便传图的小工具可选。 例如： ![avatar](http://baidu.com/pic/doge.png) image.png 把图片存入markdown文件 用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置。 基础用法： ![avatar](data:image/png;base64,iVBORw0......) 这个时候会发现插入的这一长串字符串会把整个文章分割开，非常影响编写文章时的体验。如果能够把大段的base64字符串放在文章末尾，然后在文章中通过一个id来调用，文章就不会被分割的这么乱了。 比如： ![avatar][doge] [doge]:data:image/png;base64,iVBORw0...... 然后，base64的图片编码如何得来？ 图片转化为base64字符串 image.png base64字符串转化为图片 image.png 效果演示 图片展示区域 image.png 代码区域 [base64str]:data:image/png;base64,iVBORw0KGg... ","link":"https://tong125847.github.io/post/cha-ru-tu-pian-markdown/"},{"title":"视频插入Markdown","content":"&lt;iframe height=&quot;400&quot; width=&quot;600&quot; src=&quot;请输入哔哩哔哩视频地址！updating！！！&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;&lt;!-- 全屏允许 --&gt; ","link":"https://tong125847.github.io/post/shi-pin/"},{"title":"网站分享","content":"http://www.mindline.cn/?src=baidu 思维导图 https://blog.csdn.net/u014061630/article/details/81359144#25-%E4%BB%A3%E7%A0%81%E5%9D%97 markdown入门（CSDN） ","link":"https://tong125847.github.io/post/wang-zhan-fen-xiang/"},{"title":"This is a HTML test!","content":"&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;title&gt;The Tong&amp;#39;s blog&lt;/title&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;http://localhost:4000/favicon.ico?v=1599744207804&quot;&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://localhost:4000/styles/main.css&quot;&gt; &lt;link rel=&quot;alternate&quot; type=&quot;application/atom+xml&quot; title=&quot;The Tong&amp;#39;s blog - Atom Feed&quot; href=&quot;http://localhost:4000/atom.xml&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Droid+Serif:400,700&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;最高处见！&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;main-content&quot;&gt; &lt;div class=&quot;site-header&quot;&gt; &lt;a href=&quot;http://localhost:4000&quot;&gt; &lt;img class=&quot;avatar&quot; src=&quot;http://localhost:4000/images/avatar.png?v=1599744207804&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;h1 class=&quot;site-title&quot;&gt; The Tong&amp;#39;s blog &lt;/h1&gt; &lt;p class=&quot;site-description&quot;&gt; 最高处见！ &lt;/p&gt; &lt;div class=&quot;menu-container&quot;&gt; &lt;a href=&quot;/&quot; class=&quot;menu&quot;&gt; 首页 &lt;/a&gt; &lt;a href=&quot;/archives&quot; class=&quot;menu&quot;&gt; 归档 &lt;/a&gt; &lt;a href=&quot;/tags&quot; class=&quot;menu&quot;&gt; 标签 &lt;/a&gt; &lt;a href=&quot;/post/about&quot; class=&quot;menu&quot;&gt; 关于 &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;social-container&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;tags-container&quot;&gt; &lt;a class=&quot;tag&quot; href=&quot;http://localhost:4000/tag/UBXtgiV2B/&quot;&gt;Gridea&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;site-footer&quot;&gt; Powered by &lt;a href=&quot;https://github.com/getgridea/gridea&quot; target=&quot;_blank&quot;&gt;Gridea&lt;/a&gt; &lt;a class=&quot;rss&quot; href=&quot;http://localhost:4000/atom.xml&quot; target=&quot;_blank&quot;&gt; &lt;i class=&quot;ri-rss-line&quot;&gt;&lt;/i&gt; RSS &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://tong125847.github.io/post/this-is-a-html-test/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://tong125847.github.io/post/hello-gridea/"}]}