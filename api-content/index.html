{"posts":[{"title":"链表","content":"#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct student { int num; int score; char name[20]; struct student *next; } STU; //链表创建(尾插法) void link_creat_head(STU **p_head,STU *p_new) { STU *p_mov=*p_head; if(*p_head==NULL) {*p_head=p_new; p_new-&gt;next=NULL; } else { while(p_mov-&gt;next!=NULL) {p_mov=p_mov-&gt;next; } p_mov-&gt;next=p_new; p_new-&gt;next=NULL; } } //遍历链表 void link_print(STU *head) { STU *p_mov; p_mov=head; while(p_mov!=NULL) { printf(&quot;num=%d,score=%d,name=%s\\n&quot;,p_mov-&gt;num,p_mov-&gt;score,p_mov-&gt;name); p_mov=p_mov-&gt;next; } } //释放链表 void link_free(STU **p_head) { STU *pb=*p_head; while(*p_head!=NULL) { pb=*p_head; *p_head=(*p_head)-&gt;next; free(pb); pb=NULL; } printf(&quot;链表释放成功&quot;); } //链表的查找（查找某个学号） STU* link_search_num(STU *head,int num) { STU *p_mov; p_mov=head; while(p_mov!=NULL) { if(p_mov-&gt;num==num) { printf(&quot;找到了！！&quot;); return p_mov; } p_mov=p_mov-&gt;next; } printf(&quot;没找到！&quot;); return NULL; } //链表的查找（查找某个姓名） STU *link_search_name(STU *head,char *name) { STU *p_mov; p_mov=head; while(p_mov!=NULL) { if(strcmp(p_mov-&gt;name,name)==0) { printf(&quot;找到了！！&quot;); return p_mov; } } printf(&quot;没找到！&quot;); return NULL; } //链表节点的删除 void link_delete_num(STU **p_head,int num) { STU *pb,*pf; pb=*p_head;pf=*p_head; if(*p_head==NULL) { printf(&quot;链表为空，没有您要删除的节点&quot;); return; } while((pb-&gt;num!=num)&amp;&amp;(pb-&gt;next!=NULL)) { pf=pb; pb=pb-&gt;next; } if(pb-&gt;num==num) { if(pb==*p_head) { *p_head=pb-&gt;next; printf(&quot;已删除\\n&quot;); } else { printf(&quot;删除成功\\n&quot;); pf-&gt;next=pb-&gt;next; } free(pb); } else { printf(&quot;没有您要删除的节点&quot;); } } //插入指定位置前中后 void link_insert_num(STU **p_head,STU *p_new) { STU *pb,*pf; pb=pf=*p_head; if(*p_head==NULL) { *p_head=p_new; p_new-&gt;next=NULL; return ; } while((p_new-&gt;num&gt;=pb-&gt;num)&amp;&amp;(pb-&gt;next!=NULL)) { pf=pb; pb=pb-&gt;next; } if(p_new-&gt;num&lt;pb-&gt;num) { p_new-&gt;next=*p_head; *p_head=p_new; } else { pb-&gt;next=p_new; p_new-&gt;next=NULL; } } //链表的排序 void link_order(STU *head) { STU *pb,*pf,temp; pf=head; if(head==NULL) { printf(&quot;链表为空，不用排序&quot;); return; } if(head-&gt;next==NULL) { printf(&quot;只有一个节点，不用排序&quot;); return; } while(pf-&gt;next!=NULL) { pb=pf-&gt;next; while(pb!=NULL) { if(pf-&gt;num&gt;pb-&gt;num) {temp=*pb; *pb=*pf; *pf=temp; temp.next=pb-&gt;next; pb-&gt;next=pf-&gt;next; pf-&gt;next=temp.next; } pb=pb-&gt;next; } pf=pf-&gt;next; } } //链表逆序 STU *link_reverse(STU *head) { STU *pf,*pb,*r; pf=head; pb=pf-&gt;next; while(pb!=NULL) { r=pb-&gt;next; pb-&gt;next=pf; pf=pb; pb=r; } head-&gt;next=NULL; head=pf; return head; } int main() { STU *head=NULL,*p_new=NULL; int num,i; printf(&quot;请输入链表初始化个数\\n&quot;); scanf(&quot;%d&quot;,&amp;num); for(i=0;i&lt;num;i++) { p_new=(STU*)malloc(sizeof(STU)); printf(&quot;请输入学号、分数、名字：\\n&quot;); scanf(&quot;%d %d %s&quot;,&amp;p_new-&gt;num,&amp;p_new-&gt;score,p_new-&gt;name); link_creat_head(&amp;head,p_new); } link_print(head); //link_free(&amp;head); // link_search_num(head,1001); // link_search_name(head,&quot;xxx&quot;); link_delete_num(&amp;head,1001); /* while(1) { printf(&quot;请输入您要插入的节点的num score name\\n&quot;); p_new=(STU*)malloc(sizeof(STU)); scanf(&quot;%d %d %s&quot;,&amp;p_new-&gt;num,&amp;p_new-&gt;score,p_new-&gt;name); link_insert_num(&amp;head,p_new); link_print(head); }*/ //link_order(head); printf(&quot;**********************\\n&quot;); //head=link_reverse(head); link_print(head); link_free(&amp;head); return 0; } ","link":"https://tong125847.github.io/post/lian-biao/"},{"title":"C语言随记","content":"结构体字节对齐，C语言结构体字节对齐详解 struct STUDENT { char a; int b; }data; 如上结构体变量 data 占多少字节？char 占 1 字节，int 占 4 字节，所以总共占 5 字节吗？我们写一个程序验证一下： # include &lt;stdio.h&gt; struct STUDENT { char a; int b; }data; int main(void) { printf(&quot;%p, %p\\n&quot;, &amp;data.a, &amp;data.b); //%p是取地址输出控制符 printf(&quot;%d\\n&quot;, sizeof(data)); return 0; } 输出结果是： 00427E68, 00427E6C 8 我们看到 data 不是占 5 字节，而是占 8 字节。变量 a 的地址是从 00427E68 到 00427E6B，占 4字 节；变量 b 的地址是从 00427E6C 到 00427E6F，也占 4 字节。b 占 4 字节我们能理解，但 a 是 char 型，char 型不是占 1 字节吗，这里为什么占 4 字节？其实不是它占了 4 字节，它占的还是 1 字节，只不过结构体中有一个字节对齐的概念。 什么叫字节对齐？我们知道结构体是一种构造数据类型，里面可以有不同数据类型的成员。在这些成员中，不同的数据类型所占的内存空间是不同的。那么系统是怎么给结构体变量的成员分配内存的呢？或者说这些成员在内存中是如何存储的呢？通过上面这个例子我们知道肯定不是顺序存储的。 那么到底是怎么存储的呢？就是按字节对齐的方式存储的！即以结构体成员中占内存最多的数据类型所占的字节数为标准，所有的成员在分配内存时都要与这个长度对齐。我们举一个例子：我们以上面这个程序为例，结构体变量 data 的成员中占内存最多的数据类型是 int 型，其占 4 字节的内存空间，那么所有成员在分配内存时都要与 4 字节的长度对齐。也就是说，虽然 char 只占 1 字节，但是为了与 4 字节的长度对齐，它后面的 3 字节都会空着，即： 所谓空着其实也不是里面真的什么都没有，它就同定义了一个变量但没有初始化一样，里面是一个很小的、负的填充字。为了便于表达，我们就暂且称之为空好了。 如果结构体成员为： struct STUDENT { char a; char b; int c; }data; 那么这三个成员是怎么对齐的？a 和 b 后面都是空 3 字节吗？不是！如果没有 b，那么 a 后面就空 3 字节，有了 b 则 b 就接着 a 后面填充。即： 所以这时候结构体变量 data 仍占 8 字节。我们写一个程序验证一下： # include &lt;stdio.h&gt; struct STUDENT { char a; char b; int c; }data; int main(void) { printf(&quot;%p, %p, %p\\n&quot;, &amp;data.a, &amp;data.b, &amp;data.c); //%p是取地址输出控制符 printf(&quot;%d\\n&quot;, sizeof(data)); return 0; } 输出结果是： 00427E68, 00427E69, 00427E6C 8 这时我们发现一个问题：所有成员在分配内存的时候都与 4 字节的长度对齐，多个 char 类型时是依次往后填充，但是 char 型后面的 int 型为什么不紧接着后面填充？为什么要另起一行？也就是说，到底什么时候是接在后面填充，什么时候是另起一行填充？ 我们说，所有的成员在分配内存时都要与所有成员中占内存最多的数据类型所占内存空间的字节数对齐。假如这个字节数为 N，那么对齐的原则是：理论上所有成员在分配内存时都是紧接在前一个变量后面依次填充的，但是如果是“以 N 对齐”为原则，那么，如果一行中剩下的空间不足以填充某成员变量，即剩下的空间小于某成员变量的数据类型所占的字节数，则该成员变量在分配内存时另起一行分配。 下面再来举一个例子，大家觉得下面这个结构体变量data占多少字节？ struct STUDENT { char a; char b; char c; char d; char e; int f; }data; 首先最长的数据类型占 4 字节，所以是以 4 对齐。然后 a 占 1 字节，b 接在 a 后面占 1 字节，c 接在 b 后面占 1 字节，d 接在 c 后面占 1 字节，此时满 4 字节了，e 再来就要另起一行。f 想紧接着 e 后面分配，但 e 后面还剩 3 字节，小于 int 类型的 4 字节，所以 f 另起一行。即该结构体变量分配内存时如下： 即总共占 12 字节。我们写一个程序验证一下： # include &lt;stdio.h&gt; struct STUDENT { char a; char b; char c; char d; char e; int f; }data; int main(void) { printf(&quot;%p, %p, %p, %p, %p, %p\\n&quot;, &amp;data.a, &amp;data.b, &amp;data.c, &amp;data.d, &amp;data.e, &amp;data.f); //%p是取地址输出控制符 printf(&quot;%d\\n&quot;, sizeof(data)); return 0; } 输出结果是： 00427E68, 00427E69, 00427E6A, 00427E6B, 00427E6C, 00427E70 12 现在大家应该能掌握字节对齐的精髓了吧！下面给大家出一个题目试试掌握情况。我们将前面的结构体改一下： struct STUDENT { char a; int b; char c; }data; 即将原来第二个和第三个声明交换了位置，大家看看现在 data 变量占多少字节？没错，是 12 字节。首先最长类型所占字节数为 4，所以是以 4 对齐。分配内存的时候 a 占 1 字节，然后 b 想紧接着 a 后面存储，但 a 后面还剩 3 字节，小于 b 的 4 字节，所以 b 另起一行分配。然后 c 想紧接着 b 后面分配，但是 b 后面没空了，所以 c 另起一行分配。所以总共 12 字节。内存分配图如下所示： 下面写一个程序验证一下： # include &lt;stdio.h&gt; struct STUDENT { char a; int b; char c; }data; int main(void) { printf(&quot;%p, %p, %p\\n&quot;, &amp;data.a, &amp;data.b, &amp;data.c); //%p是取地址输出控制符 printf(&quot;%d\\n&quot;, sizeof(data)); return 0; }``` 输出结果是： 00427E68, 00427E6C, 00427E70 12 我们看到，同样三个数据类型，只不过交换了一下位置，结构体变量data所占的内存空间就由8字节变成12字节，多了4字节。这就告诉我们，在声明结构体类型时，各类型成员的前后位置会对该结构体类型定义的结构体变量所占的字节数产生影响。没有规律的定义会增加系统给结构体变量分配的字节数，降低内存分配的效率。但这种影响对操作系统来说几乎是可以忽略不计的！所以我们在写程序的时候，如果有心的话，声明结构体类型时就按成员类型所占字节数从小到大写，或从大到小写。但是如果没有按规律书写的话也不要紧，声明结构体类型时并非一定要从小到大声明，只是为了说明“字节对齐”这个概念！而且有时候为了增强程序的可读性我们就需要没有规律地写，比如存储一个人的信息： ```c struct STUDENT { char name[10]; int age; char sex; float score; }data; 正常的思维是将“性别”放在“年龄”后面，但如果为了内存对齐而交换它们的位置，总让人觉得有点别扭。所以我说“尽量”有规律地写！ 这时又有人会提出一个问题：“上面这个结构体变量 data 中有成员 char name[10]，长度最长，是 10，那是不是要以 10 对齐？”不是，char a[10] 的本质是 10 个 char 变量，所以就把它当成 10 个 char 变量看就行了。所以结构体变量 data 中成员最长类型占 4 字节，还是以 4 对齐。该结构体变量分配内存时情况如下： 总共 24 字节，我们写一个程序验证一下： # include &lt;stdio.h&gt; struct STUDENT { char name[10]; int age; char sex; float score; }data; int main(void) { printf(&quot;%p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p, %p\\n&quot;, &amp;data.name[0], &amp;data.name[1], &amp;data.name[2], &amp;data.name[3], &amp;data.name[4], &amp;data.name[5], &amp;data.name[6], &amp;data.name[7], &amp;data.name[8], &amp;data.name[9], &amp;data.age, &amp;data.sex, &amp;data.score); printf(&quot;%d\\n&quot;, sizeof(data)); return 0; } 输出结果是： 00427E68, 00427E69, 00427E6A, 00427E6B, 00427E6C, 00427E6D, 00427E6E, 00427E6F, 00427E70, 00427E71, 00427E74, 00427E78, 00427E7C 24 ","link":"https://tong125847.github.io/post/c-yu-yan-sui-ji/"},{"title":"Ubuntu学习（第一天）","content":"==========开发环境================= Ubuntu 16.04 64位的linux 系统 Ubuntu 12.04 32位的linux系统 6818开发板---32位的linux内核，使用是linux内核6.25.7.35版本 如果要用64位系统开发32位的开发板，需要搭建编译工具环境 ==========Linux设置共享文件夹========== （1）在电脑中新建一个可以共享的文件夹 （2）点击”虚拟机”---“设置”---“选项”---“共享文件夹” ---“总是启用”---“添加”---输入被共享的文件夹名称，然 后一直点“下一步”，直到“完成”。 &lt;www.kernel.org&gt; ===========常用linux命令============= （1）cd进入或者退出文件夹 cd .. 退出当前文件夹，回到上一级目录 cd +文件夹名称 进入到该文件夹 （2）ls 查看文件夹内容 ls 查看当前文件夹的名称 ls -l 查看当前文件夹中文件的详细信 （3）touch 创建文件 （4）rm 删除文件 （5）mkdir 创建文件夹 mkdir + 名称 （6）rmdir 删除文件夹(默认要求文件夹为空) （7）cp 拷贝文件 cp 文件1 文件2 拷贝普通文件 其他命令：chmod，ifconfig,mv等等 练习一： 设置共享文件夹，在共享文件夹中创建111,222,333 三个文件夹，并且在文件夹中分别创建同名文件，然后使用cp命令拷贝111文件夹成777。 ================================= 修改终端颜色： 在终端的任意空白位置，右键选择“Profiles”----“Profiles Preference”----“color”就可以自行调整终端的颜色 rm 文件名称 -rf 强制删除文件，不管该文件是什么 pwd :查看当前所在的路径 /mnt/hgfs：ubuntu共享文件夹的标准前缀。 写代码的文件: 源代码 可以运行的文件: 可执行程序 编译程序： gcc 源代码 ‘-o’ 可执行程序 运行可执行程序: ./可执行程序 建议同学们在编写程序的时候，把“文件扩展名”√上，防止文件名弄错。 ===============程序编译================== （1）解析头文件，解析宏定义 得到的hello.i仍然是高级语言 （2）把高级语言转成汇编语言 得到的hello.s是汇编语言 （3）把汇编语言转成二进制机器语言 得到的hello.o就是机器语言 （4）把一个或多个链接文件组合成一个可执行程序 得到的就是可执行文件 综合在一起： =======================C语言常用结构======================= （1）数据类型 int类型 4字节 存放整型数据 char类型 1字节 存放字符类型数据，但同样也可以表示0~255的数值。 具体数值可以查看ASCII表格，使用”man ASCII”。 （2）循环 for循环 for(初始条件 ； 判断条件 ； 结束动作 ) { 执行动作 } 当初始条件满足判断条件并且为真的时候，程序运行”执行动作”,当“执行动作”结束以后，运行一次“结束动作”，然后再”判断条件”。 while循环 while(判断条件) { 执行动作 } 当判断条件是真的时候，程序运行执行动作 使用printf打印倒的三层三角形 ***** *** * test1.c 练习2： 使用printf打印：正的四层三角形 * *** ***** ******* 作业： 在网络上找一个叫做“2048”的游戏，然后了解其中的数学逻辑。 //data_type #include &lt;stdio.h&gt; int main() { int a=100; printf(&quot;地址=%p\\n&quot;,&amp;a); printf(&quot;大小=%d\\n&quot;,sizeof(a)); char b = 'A'; printf(&quot;b=%d,b=%p\\n&quot;,b,&amp;b); return 0; } //for #include &lt;stdio.h&gt; int main() { int i; //变量i从数值0开始，如果它的数值小于5，那么就执行{}里面的内容 //并且每次执行完毕以后，进行 i++ ,也就是自己加1 //直到i的数值大于等于5的时候，就不再执行{}里面的内容。 for(i=0;i&lt;5;i++) { printf(&quot;i=%d\\n&quot;,i); } return 0; } //hello #include &lt;stdio.h&gt; int main() { int a=100; printf(&quot;地址=%p\\n&quot;,&amp;a); printf(&quot;大小=%d\\n&quot;,sizeof(a)); char b = 'A'; printf(&quot;b=%d,b=%p\\n&quot;,b,&amp;b); return 0; } //test1 #include &lt;stdio.h&gt; int main() { int i,j; for(i=0;i&lt;3;i++) { for(j=0;j&lt;i;j++) printf(&quot; &quot;); for(j=0;j&lt;2*(2-i)+1;j++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); } /******* 第一次输出： i=0的时候 j也是从0开始，j&lt;i 不成立，不会打印&quot; &quot; j&lt;2*(2-0)+1 一共会执行5次 第二次输出： i=1的时候 j&lt;i成立，打印一次&quot; &quot; j&lt;2*(2-1)+1 一共会执行3次 第三次输出： i=2的时候 j&lt;i成立，打印两次&quot; &quot; j&lt;2*(2-2)+1 一共会执行1次 *******/ return 0; } //test2 #include &lt;stdio.h&gt; int main() { int ceng = 7; int i,j; for(i=0;i&lt;ceng;i++) { for(j=0;j&lt;ceng-1-i;j++) printf(&quot; &quot;); for(j=0;j&lt;2*i+1;j++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); } return 0; } //while #include &lt;stdio.h&gt; int main() { int i=0; //只要i小于5，就执行{}里面的内容 while(i&lt;5) { printf(&quot;i=%d\\n&quot;,i); i++; } return 0; } ","link":"https://tong125847.github.io/post/ubuntu-xue-xi-2020-11-02di-yi-tian/"},{"title":"插入图片Markdown","content":"Markdown插图片有三种方法，各种Markdown编辑器的插图方式也都包含在这三种方法之内。 插图最基础的格式就是： ![Alt text](图片链接 &quot;optional title&quot;) image.png 插入本地图片 只需要在基础语法的括号中填入图片的位置路径即可，支持绝对路径和相对路径。 例如： ![avatar](/home/picture/1.png) image.png 插入网络图片 只需要在基础语法的括号中填入图片的网络链接即可，现在已经有很多免费/收费图床和方便传图的小工具可选。 例如： ![avatar](http://baidu.com/pic/doge.png) image.png 把图片存入markdown文件 用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置。 基础用法： ![avatar](data:image/png;base64,iVBORw0......) 这个时候会发现插入的这一长串字符串会把整个文章分割开，非常影响编写文章时的体验。如果能够把大段的base64字符串放在文章末尾，然后在文章中通过一个id来调用，文章就不会被分割的这么乱了。 比如： ![avatar][doge] [doge]:data:image/png;base64,iVBORw0...... 然后，base64的图片编码如何得来？ 图片转化为base64字符串 image.png base64字符串转化为图片 image.png 效果演示 图片展示区域 image.png 代码区域 [base64str]:data:image/png;base64,iVBORw0KGg... ","link":"https://tong125847.github.io/post/cha-ru-tu-pian-markdown/"},{"title":"视频插入Markdown","content":"&lt;iframe height=&quot;400&quot; width=&quot;600&quot; src=&quot;请输入哔哩哔哩视频地址！updating！！！&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;&lt;!-- 全屏允许 --&gt; ","link":"https://tong125847.github.io/post/shi-pin/"},{"title":"网站分享","content":"http://www.mindline.cn/?src=baidu 思维导图 https://blog.csdn.net/u014061630/article/details/81359144#25-%E4%BB%A3%E7%A0%81%E5%9D%97 markdown入门（CSDN） ","link":"https://tong125847.github.io/post/wang-zhan-fen-xiang/"},{"title":"This is a HTML test!","content":"&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;title&gt;The Tong&amp;#39;s blog&lt;/title&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;http://localhost:4000/favicon.ico?v=1599744207804&quot;&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://localhost:4000/styles/main.css&quot;&gt; &lt;link rel=&quot;alternate&quot; type=&quot;application/atom+xml&quot; title=&quot;The Tong&amp;#39;s blog - Atom Feed&quot; href=&quot;http://localhost:4000/atom.xml&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Droid+Serif:400,700&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;最高处见！&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;main-content&quot;&gt; &lt;div class=&quot;site-header&quot;&gt; &lt;a href=&quot;http://localhost:4000&quot;&gt; &lt;img class=&quot;avatar&quot; src=&quot;http://localhost:4000/images/avatar.png?v=1599744207804&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;h1 class=&quot;site-title&quot;&gt; The Tong&amp;#39;s blog &lt;/h1&gt; &lt;p class=&quot;site-description&quot;&gt; 最高处见！ &lt;/p&gt; &lt;div class=&quot;menu-container&quot;&gt; &lt;a href=&quot;/&quot; class=&quot;menu&quot;&gt; 首页 &lt;/a&gt; &lt;a href=&quot;/archives&quot; class=&quot;menu&quot;&gt; 归档 &lt;/a&gt; &lt;a href=&quot;/tags&quot; class=&quot;menu&quot;&gt; 标签 &lt;/a&gt; &lt;a href=&quot;/post/about&quot; class=&quot;menu&quot;&gt; 关于 &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;social-container&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;tags-container&quot;&gt; &lt;a class=&quot;tag&quot; href=&quot;http://localhost:4000/tag/UBXtgiV2B/&quot;&gt;Gridea&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;site-footer&quot;&gt; Powered by &lt;a href=&quot;https://github.com/getgridea/gridea&quot; target=&quot;_blank&quot;&gt;Gridea&lt;/a&gt; &lt;a class=&quot;rss&quot; href=&quot;http://localhost:4000/atom.xml&quot; target=&quot;_blank&quot;&gt; &lt;i class=&quot;ri-rss-line&quot;&gt;&lt;/i&gt; RSS &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://tong125847.github.io/post/this-is-a-html-test/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://tong125847.github.io/post/hello-gridea/"}]}